<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.10"/>
<title>OpenCL C++ Bindings: Main Page</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OpenCL C++ Bindings
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.10 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('index.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">OpenCL C++ Bindings Documentation</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="intro"></a>
Introduction</h1>
<p>For many large applications C++ is the language of choice and so it seems reasonable to define C++ bindings for OpenCL.</p>
<p>The interface is contained with a single C++ header file <em><a class="el" href="cl2_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 48), OpenCL 1.1 (rev 33), OpenCL 1.2 (rev 15) and OpenCL 2...">cl2.hpp</a></em> and all definitions are contained within the namespace <em>cl</em>. There is no additional requirement to include <em>cl.h</em> and to use either the C++ or original C bindings; it is enough to simply include <em><a class="el" href="cl2_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 48), OpenCL 1.1 (rev 33), OpenCL 1.2 (rev 15) and OpenCL 2...">cl2.hpp</a></em>.</p>
<p>The bindings themselves are lightweight and correspond closely to the underlying C API. Using the C++ bindings introduces no additional execution overhead.</p>
<p>There are numerous compatibility, portability and memory management fixes in the new header as well as additional OpenCL 2.0 features. As a result the header is not directly backward compatible and for this reason we release it as <a class="el" href="cl2_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 48), OpenCL 1.1 (rev 33), OpenCL 1.2 (rev 15) and OpenCL 2...">cl2.hpp</a> rather than a new version of cl.hpp.</p>
<h1><a class="anchor" id="compatibility"></a>
Compatibility</h1>
<p>Due to the evolution of the underlying OpenCL API the 2.0 C++ bindings include an updated approach to defining supported feature versions and the range of valid underlying OpenCL runtime versions supported.</p>
<p>The combination of preprocessor macros CL_HPP_TARGET_OPENCL_VERSION and CL_HPP_MINIMUM_OPENCL_VERSION control this range. These are three digit decimal values representing OpenCL runime versions. The default for the target is 200, representing OpenCL 2.0 and the minimum is also defined as 200. These settings would use 2.0 API calls only. If backward compatibility with a 1.2 runtime is required, the minimum version may be set to 120.</p>
<p>Note that this is a compile-time setting, and so affects linking against a particular SDK version rather than the versioning of the loaded runtime.</p>
<p>The earlier versions of the header included basic vector and string classes based loosely on STL versions. These were difficult to maintain and very rarely used. For the 2.0 header we now assume the presence of the standard library unless requested otherwise. We use std::array, std::vector, std::shared_ptr and std::string throughout to safely manage memory and reduce the chance of a recurrance of earlier memory management bugs.</p>
<p>These classes are used through typedefs in the cl namespace: cl::array, cl::vector, cl::pointer and cl::string. In addition <a class="el" href="namespacecl.html#a9feaebcb39a179537588bfcd349dbbb6">cl::allocate_pointer</a> forwards to std::allocate_shared by default. In all cases these standard library classes can be replaced with custom interface-compatible versions using the CL_HPP_NO_STD_ARRAY, CL_HPP_NO_STD_VECTOR, CL_HPP_NO_STD_UNIQUE_PTR and CL_HPP_NO_STD_STRING macros.</p>
<p>The OpenCL 1.x versions of the C++ bindings included a size_t wrapper class to interface with kernel enqueue. This caused unpleasant interactions with the standard size_t declaration and led to namespacing bugs. In the 2.0 version we have replaced this with a std::array-based interface. However, the old behaviour can be regained for backward compatibility using the CL_HPP_ENABLE_SIZE_T_COMPATIBILITY macro.</p>
<p>Finally, the program construction interface used a clumsy vector-of-pairs design in the earlier versions. We have replaced that with a cleaner vector-of-vectors and vector-of-strings design. However, for backward compatibility old behaviour can be regained with the CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY macro.</p>
<p>In OpenCL 2.0 OpenCL C is not entirely backward compatibility with earlier versions. As a result a flag must be passed to the OpenCL C compiled to request OpenCL 2.0 compilation of kernels with 1.2 as the default in the absence of the flag. In some cases the C++ bindings automatically compile code for ease. For those cases the compilation defaults to OpenCL C 2.0. If this is not wanted, the CL_HPP_CL_1_2_DEFAULT_BUILD macro may be specified to assume 1.2 compilation. If more fine-grained decisions on a per-kernel bases are required then explicit build operations that take the flag should be used.</p>
<h1><a class="anchor" id="parameterization"></a>
Parameters</h1>
<p>This header may be parameterized by a set of preprocessor macros.</p>
<ul>
<li><p class="startli">CL_HPP_TARGET_OPENCL_VERSION</p>
<p class="startli">Defines the target OpenCL runtime version to build the header against. Defaults to 200, representing OpenCL 2.0.</p>
</li>
<li><p class="startli">CL_HPP_NO_STD_STRING</p>
<p class="startli">Do not use the standard library string class. cl::string is not defined and may be defined by the user before <a class="el" href="cl2_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 48), OpenCL 1.1 (rev 33), OpenCL 1.2 (rev 15) and OpenCL 2...">cl2.hpp</a> is included.</p>
</li>
<li><p class="startli">CL_HPP_NO_STD_VECTOR</p>
<p class="startli">Do not use the standard library vector class. cl::vector is not defined and may be defined by the user before <a class="el" href="cl2_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 48), OpenCL 1.1 (rev 33), OpenCL 1.2 (rev 15) and OpenCL 2...">cl2.hpp</a> is included.</p>
</li>
<li><p class="startli">CL_HPP_NO_STD_ARRAY</p>
<p class="startli">Do not use the standard library array class. cl::array is not defined and may be defined by the user before <a class="el" href="cl2_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 48), OpenCL 1.1 (rev 33), OpenCL 1.2 (rev 15) and OpenCL 2...">cl2.hpp</a> is included.</p>
</li>
<li><p class="startli">CL_HPP_NO_STD_UNIQUE_PTR</p>
<p class="startli">Do not use the standard library unique_ptr class. cl::pointer and the <a class="el" href="namespacecl.html#a9feaebcb39a179537588bfcd349dbbb6">cl::allocate_pointer</a> functions are not defined and may be defined by the user before <a class="el" href="cl2_8hpp.html" title="C++ bindings for OpenCL 1.0 (rev 48), OpenCL 1.1 (rev 33), OpenCL 1.2 (rev 15) and OpenCL 2...">cl2.hpp</a> is included.</p>
</li>
<li><p class="startli">CL_HPP_ENABLE_DEVICE_FISSION</p>
<p class="startli">Enables device fission for OpenCL 1.2 platforms.</p>
</li>
<li><p class="startli">CL_HPP_ENABLE_EXCEPTIONS</p>
<p class="startli">Enable exceptions for use in the C++ bindings header. This is the preferred error handling mechanism but is not required.</p>
</li>
<li><p class="startli">CL_HPP_ENABLE_SIZE_T_COMPATIBILITY</p>
<p class="startli">Backward compatibility option to support cl.hpp-style size_t class. Replaces the updated std::array derived version and removal of size_t from the namespace. Note that in this case the new size_t class is placed in the cl::compatibility namespace and thus requires an additional using declaration for direct backward compatibility.</p>
</li>
<li><p class="startli">CL_HPP_ENABLE_PROGRAM_CONSTRUCTION_FROM_ARRAY_COMPATIBILITY</p>
<p class="startli">Enable older vector of pairs interface for construction of programs.</p>
</li>
<li><p class="startli">CL_HPP_CL_1_2_DEFAULT_BUILD</p>
<p class="startli">Default to OpenCL C 1.2 compilation rather than OpenCL C 2.0 applies to use of <a class="el" href="classcl_1_1_program.html" title="Program interface that implements cl_program. ">cl::Program</a> construction and other program build variants.</p>
</li>
</ul>
<h1><a class="anchor" id="example"></a>
Example</h1>
<p>The following example shows a general use case for the C++ bindings, including support for the optional exception feature and also the supplied vector and string classes, see following sections for decriptions of these features.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define CL_HPP_ENABLE_EXCEPTIONS</span></div>
<div class="line"><span class="preprocessor">#define CL_HPP_TARGET_OPENCL_VERSION 200</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cl2_8hpp.html">CL/cl2.hpp</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;iostream&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;memory&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">int</span> numElements = 32;</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// Filter for a 2.0 platform and set it as the default</span></div>
<div class="line">    std::vector&lt;cl::Platform&gt; platforms;</div>
<div class="line">    <a class="code" href="classcl_1_1_platform.html#af15bd8dced161daee0c5289178c8a0e1">cl::Platform::get</a>(&amp;platforms);</div>
<div class="line">    <a class="code" href="classcl_1_1_platform.html">cl::Platform</a> plat;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;p : platforms) {</div>
<div class="line">        std::string platver = p.<a class="code" href="classcl_1_1_platform.html#a84262a3c349b6514f70de0dacb72b205">getInfo</a>&lt;CL_PLATFORM_VERSION&gt;();</div>
<div class="line">        <span class="keywordflow">if</span> (platver.find(<span class="stringliteral">&quot;OpenCL 2.&quot;</span>) != std::string::npos) {</div>
<div class="line">            plat = p;</div>
<div class="line">        }</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">if</span> (plat() == 0)  {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;No OpenCL 2.0 platform found.&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcl_1_1_platform.html">cl::Platform</a> newP = <a class="code" href="classcl_1_1_platform.html#afcf93176bebefc3add081c2d93935453">cl::Platform::setDefault</a>(plat);</div>
<div class="line">    <span class="keywordflow">if</span> (newP != plat) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;Error setting default platform.&quot;</span>;</div>
<div class="line">        <span class="keywordflow">return</span> -1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Use C++11 raw string literals for kernel source code</span></div>
<div class="line">    std::string kernel1{R<span class="stringliteral">&quot;CLC(</span></div>
<div class="line"><span class="stringliteral">        global int globalA;</span></div>
<div class="line"><span class="stringliteral">        kernel void updateGlobal()</span></div>
<div class="line"><span class="stringliteral">        {</span></div>
<div class="line"><span class="stringliteral">          globalA = 75;</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">    )CLC&quot;};</span></div>
<div class="line"><span class="stringliteral">    std::string kernel2{R</span><span class="stringliteral">&quot;CLC(</span></div>
<div class="line"><span class="stringliteral">        typedef struct { global int *bar; } Foo;</span></div>
<div class="line"><span class="stringliteral">        kernel void vectorAdd(global const Foo* aNum, global const int *inputA, global const int *inputB,</span></div>
<div class="line"><span class="stringliteral">                              global int *output, int val, write_only pipe int outPipe, queue_t childQueue)</span></div>
<div class="line"><span class="stringliteral">        {</span></div>
<div class="line"><span class="stringliteral">          output[get_global_id(0)] = inputA[get_global_id(0)] + inputB[get_global_id(0)] + val + *(aNum-&gt;bar);</span></div>
<div class="line"><span class="stringliteral">          write_pipe(outPipe, &amp;val);</span></div>
<div class="line"><span class="stringliteral">          queue_t default_queue = get_default_queue();</span></div>
<div class="line"><span class="stringliteral">          ndrange_t ndrange = ndrange_1D(get_global_size(0)/2, get_global_size(0)/2);</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">          // Have a child kernel write into third quarter of output</span></div>
<div class="line"><span class="stringliteral">          enqueue_kernel(default_queue, CLK_ENQUEUE_FLAGS_WAIT_KERNEL, ndrange,</span></div>
<div class="line"><span class="stringliteral">            ^{</span></div>
<div class="line"><span class="stringliteral">                output[get_global_size(0)*2 + get_global_id(0)] =</span></div>
<div class="line"><span class="stringliteral">                  inputA[get_global_size(0)*2 + get_global_id(0)] + inputB[get_global_size(0)*2 + get_global_id(0)] + globalA;</span></div>
<div class="line"><span class="stringliteral">            });</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">          // Have a child kernel write into last quarter of output</span></div>
<div class="line"><span class="stringliteral">          enqueue_kernel(childQueue, CLK_ENQUEUE_FLAGS_WAIT_KERNEL, ndrange,</span></div>
<div class="line"><span class="stringliteral">            ^{</span></div>
<div class="line"><span class="stringliteral">                output[get_global_size(0)*3 + get_global_id(0)] =</span></div>
<div class="line"><span class="stringliteral">                  inputA[get_global_size(0)*3 + get_global_id(0)] + inputB[get_global_size(0)*3 + get_global_id(0)] + globalA + 2;</span></div>
<div class="line"><span class="stringliteral">            });</span></div>
<div class="line"><span class="stringliteral">        }</span></div>
<div class="line"><span class="stringliteral">    )CLC&quot;};</span></div>
<div class="line"><span class="stringliteral"></span></div>
<div class="line"><span class="stringliteral">    </span><span class="comment">// New simpler string interface style</span></div>
<div class="line">    std::vector&lt;std::string&gt; programStrings {kernel1, kernel2};</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcl_1_1_program.html">cl::Program</a> vectorAddProgram(programStrings);</div>
<div class="line">    <span class="keywordflow">try</span> {</div>
<div class="line">        vectorAddProgram.build(<span class="stringliteral">&quot;-cl-std=CL2.0&quot;</span>);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordflow">catch</span> (...) {</div>
<div class="line">        <span class="comment">// Print build info for all devices</span></div>
<div class="line">        cl_int buildErr = CL_SUCCESS;</div>
<div class="line">        <span class="keyword">auto</span> buildInfo = vectorAddProgram.getBuildInfo&lt;CL_PROGRAM_BUILD_LOG&gt;(&amp;buildErr);</div>
<div class="line">        <span class="keywordflow">for</span> (<span class="keyword">auto</span> &amp;pair : buildInfo) {</div>
<div class="line">            std::cerr &lt;&lt; pair.second &lt;&lt; std::endl &lt;&lt; std::endl;</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">return</span> 1;</div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">typedef</span> <span class="keyword">struct </span>{ <span class="keywordtype">int</span> *bar; } Foo;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Get and run kernel that initializes the program-scope global</span></div>
<div class="line">    <span class="comment">// A test for kernels that take no arguments</span></div>
<div class="line">    <span class="keyword">auto</span> program2Kernel =</div>
<div class="line">        <a class="code" href="classcl_1_1_kernel_functor.html">cl::KernelFunctor&lt;&gt;</a>(vectorAddProgram, <span class="stringliteral">&quot;updateGlobal&quot;</span>);</div>
<div class="line">    program2Kernel(</div>
<div class="line">        <a class="code" href="classcl_1_1_enqueue_args.html">cl::EnqueueArgs</a>(</div>
<div class="line">        <a class="code" href="classcl_1_1_n_d_range.html">cl::NDRange</a>(1)));</div>
<div class="line"></div>
<div class="line">    <span class="comment">// SVM allocations</span></div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> anSVMInt = cl::allocate_svm&lt;int, cl::SVMTraitCoarse&lt;&gt;&gt;();</div>
<div class="line">    *anSVMInt = 5;</div>
<div class="line">    <a class="code" href="classcl_1_1_s_v_m_allocator.html">cl::SVMAllocator&lt;Foo, cl::SVMTraitCoarse&lt;cl::SVMTraitReadOnly&lt;&gt;</a>&gt;&gt; svmAllocReadOnly;</div>
<div class="line">    <span class="keyword">auto</span> fooPointer = cl::allocate_pointer&lt;Foo&gt;(svmAllocReadOnly);</div>
<div class="line">    fooPointer-&gt;bar = anSVMInt.get();</div>
<div class="line">    <a class="code" href="classcl_1_1_s_v_m_allocator.html">cl::SVMAllocator&lt;int, cl::SVMTraitCoarse&lt;&gt;</a>&gt; svmAlloc;</div>
<div class="line">    std::vector&lt;int, cl::SVMAllocator&lt;int, cl::SVMTraitCoarse&lt;&gt;&gt;&gt; inputA(numElements, 1, svmAlloc);</div>
<div class="line">    <a class="code" href="namespacecl.html#a51ad881a3d0a77bca3eecd01af8501c0">cl::coarse_svm_vector&lt;int&gt;</a> inputB(numElements, 2, svmAlloc);</div>
<div class="line"></div>
<div class="line">    <span class="comment">//</span></div>
<div class="line"><span class="comment"></span></div>
<div class="line">    <span class="comment">// Traditional cl_mem allocations</span></div>
<div class="line">    std::vector&lt;int&gt; output(numElements, 0xdeadbeef);</div>
<div class="line">    <a class="code" href="classcl_1_1_buffer.html">cl::Buffer</a> outputBuffer(begin(output), end(output), <span class="keyword">false</span>);</div>
<div class="line">    <a class="code" href="classcl_1_1_pipe.html">cl::Pipe</a> aPipe(<span class="keyword">sizeof</span>(cl_int), numElements / 2);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Default command queue, also passed in as a parameter</span></div>
<div class="line">    <a class="code" href="classcl_1_1_device_command_queue.html">cl::DeviceCommandQueue</a> defaultDeviceQueue = <a class="code" href="classcl_1_1_device_command_queue.html#acf98d7e70d84afc31789a6f26a95d14b">cl::DeviceCommandQueue::makeDefault</a>(</div>
<div class="line">        <a class="code" href="classcl_1_1_context.html#ad180f6f7d8b5a95710ab72f96162b051">cl::Context::getDefault</a>(), <a class="code" href="classcl_1_1_device.html#a7428cf3cdccc824c414730ed65e40a0d">cl::Device::getDefault</a>());</div>
<div class="line"></div>
<div class="line">    <span class="keyword">auto</span> vectorAddKernel =</div>
<div class="line">        <a class="code" href="classcl_1_1_kernel_functor.html">cl::KernelFunctor</a>&lt;</div>
<div class="line">            decltype(fooPointer)&amp;,</div>
<div class="line">            <span class="keywordtype">int</span>*,</div>
<div class="line">            <a class="code" href="namespacecl.html#a51ad881a3d0a77bca3eecd01af8501c0">cl::coarse_svm_vector&lt;int&gt;</a>&amp;,</div>
<div class="line">            <a class="code" href="classcl_1_1_buffer.html">cl::Buffer</a>,</div>
<div class="line">            int,</div>
<div class="line">            <a class="code" href="classcl_1_1_pipe.html">cl::Pipe</a>&amp;,</div>
<div class="line">            <a class="code" href="classcl_1_1_device_command_queue.html">cl::DeviceCommandQueue</a></div>
<div class="line">            &gt;(vectorAddProgram, <span class="stringliteral">&quot;vectorAdd&quot;</span>);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Ensure that the additional SVM pointer is available to the kernel</span></div>
<div class="line">    <span class="comment">// This one was not passed as a parameter</span></div>
<div class="line">    vectorAddKernel.setSVMPointers(anSVMInt);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Hand control of coarse allocations to runtime</span></div>
<div class="line">    <a class="code" href="namespacecl.html#a45d896e5d437b505648b399dbe1c3cac">cl::enqueueUnmapSVM</a>(anSVMInt);</div>
<div class="line">    <a class="code" href="namespacecl.html#a45d896e5d437b505648b399dbe1c3cac">cl::enqueueUnmapSVM</a>(fooPointer);</div>
<div class="line">    <a class="code" href="namespacecl.html#af9f49b386b20c55c04a9e6cd21849fd5">cl::unmapSVM</a>(inputB);</div>
<div class="line">    <a class="code" href="namespacecl.html#af9f49b386b20c55c04a9e6cd21849fd5">cl::unmapSVM</a>(output2);</div>
<div class="line"></div>
<div class="line">    cl_int error;</div>
<div class="line">    vectorAddKernel(</div>
<div class="line">        <a class="code" href="classcl_1_1_enqueue_args.html">cl::EnqueueArgs</a>(</div>
<div class="line">            <a class="code" href="classcl_1_1_n_d_range.html">cl::NDRange</a>(numElements/2),</div>
<div class="line">            <a class="code" href="classcl_1_1_n_d_range.html">cl::NDRange</a>(numElements/2)),</div>
<div class="line">        fooPointer,</div>
<div class="line">        inputA.data(),</div>
<div class="line">        inputB,</div>
<div class="line">        outputBuffer,</div>
<div class="line">        3,</div>
<div class="line">        aPipe,</div>
<div class="line">        defaultDeviceQueue,</div>
<div class="line">       error</div>
<div class="line">        );</div>
<div class="line"></div>
<div class="line">    <a class="code" href="namespacecl.html#a1197a833cdd6664f206b079f2bebd2eb">cl::copy</a>(outputBuffer, begin(output), end(output));</div>
<div class="line">    <span class="comment">// Grab the SVM output vector using a map</span></div>
<div class="line">    <a class="code" href="namespacecl.html#ae97dc5bb86e2c3c3935280a86cda301c">cl::mapSVM</a>(output2);</div>
<div class="line"></div>
<div class="line">    <a class="code" href="classcl_1_1_device.html">cl::Device</a> d = <a class="code" href="classcl_1_1_device.html#a7428cf3cdccc824c414730ed65e40a0d">cl::Device::getDefault</a>();</div>
<div class="line"></div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;Output:\n&quot;</span>;</div>
<div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 1; i &lt; numElements; ++i) {</div>
<div class="line">        std::cout &lt;&lt; <span class="stringliteral">&quot;\t&quot;</span> &lt;&lt; output[i] &lt;&lt; <span class="stringliteral">&quot;\n&quot;</span>;</div>
<div class="line">    }</div>
<div class="line">    std::cout &lt;&lt; <span class="stringliteral">&quot;\n\n&quot;</span>;</div>
<div class="line"></div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Thu Jul 21 2016 10:58:05 for OpenCL C++ Bindings by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.10 </li>
  </ul>
</div>
</body>
</html>
