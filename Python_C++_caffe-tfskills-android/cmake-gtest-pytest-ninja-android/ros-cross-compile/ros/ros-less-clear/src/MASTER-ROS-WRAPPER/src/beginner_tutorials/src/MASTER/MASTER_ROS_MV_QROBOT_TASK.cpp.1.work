
#include <ros/ros.h>
#include <image_transport/image_transport.h>
#include <opencv2/highgui/highgui.hpp>
#include <cv_bridge/cv_bridge.h>
#include "std_msgs/String.h"


#include <QROBOT_HUB_MT_H.hpp>
#include <QROBOT_MESSAGE_H.hpp>
#include <QROBOT_UTILS_H.hpp>
#include <QROBOT_GLOBAL_H.hpp>
#include <VSLAM_MV_QROBOT_TASK_H.hpp>


#include <mvVSLAM.h>
#include <EagleCamera.h>
#include <ReadImages.h>


std::mutex mut_callback_ros;
cv::Mat g_ros_cameraImage_Raw(480,640,CV_8UC1);
float g_ros_vslam_pos_x;
float g_ros_vslam_pos_y;
float g_ros_vslam_pos_z;



template<typename T>
void callback_main_1(T msg1) {
	std::lock_guard<std::mutex> lkros(mut_callback_ros);
	std::cout<<"\n" <<" main ROS FUCTION(" << __FUNCTION__  << ")-msg->frameid["<<msg1->frameid<<"]" << std::endl;
   //     g_main_in_1.push_back(msg1);
	memcpy(g_ros_cameraImage_Raw.data,msg1->image,480*640);
	g_ros_vslam_pos_x=msg1->pos[0];
	g_ros_vslam_pos_y=msg1->pos[1];
	g_ros_vslam_pos_z=msg1->pos[2];
	printf("\n main ROS Robot pose is %f,  %f,  %f\n",g_ros_vslam_pos_x,g_ros_vslam_pos_y,g_ros_vslam_pos_z);
	return;
	}


int main(int argc, char **argv) {

	ros::init(argc, argv, "talker");
	ros::NodeHandle nh;
  	image_transport::ImageTransport it(nh);
  	image_transport::Publisher pub_img = it.advertise("vlsam/image", 1);
	            ros::Publisher pub_pose = nh.advertise<std_msgs::String>("vslam/pose",1);

	using namespace qrobot;
	/*Date_P dt(99, 99, 77);
	DEBUG_T_V("MMMMMMMMMMM...",Date_P,dt);*/
	algo_task1  m_algo_task1("VSLAM");
	std::thread     prod1(m_algo_task1);
	std::string error("   ok           ");
	mhub.subscribe<std::shared_ptr<qrobot_msg_type1>>("main","topic1",g_subs_queue_size,0,std::bind(callback_main_1<std::shared_ptr<qrobot_msg_type1>>,std::placeholders::_1),error);
	/*algo_task2  m_algo_task2("THREAD2");
        std::thread       prod2(m_algo_task2);

	algo_task3  m_algo_task3("THREAD3");
	std::thread       prod3(m_algo_task3);
	*/

	ros::Rate loop_rate(10);
        int count = 0;
        while (ros::ok()){
		std_msgs::String msg;
		std::stringstream ss;
		//ss << "ROS msg" << count<<" vslam_pose_x="<< std::to_string(g_vslam_pos_x)<<" vslam_pose_y="<< std::to_string(g_vslam_pos_y)<<" vslam_pose_z="<< std::to_string(g_vslam_pos_z);
		ss << "main ROS msg" << count<<" vslam_ros_pose_x="<< std::to_string(g_ros_vslam_pos_x)<<" vslam_ros_pose_y="<< std::to_string(g_ros_vslam_pos_y)<<" vslam_ros_pose_z="<< std::to_string(g_ros_vslam_pos_z);
		msg.data = ss.str();
		ROS_INFO("%s", msg.data.c_str());
		pub_pose.publish(msg);
		//sensor_msgs::ImagePtr msg_img = cv_bridge::CvImage(std_msgs::Header(), "mono8", g_cameraImage_Raw).toImageMsg();
		sensor_msgs::ImagePtr msg_img = cv_bridge::CvImage(std_msgs::Header(), "mono8", g_ros_cameraImage_Raw).toImageMsg();
    		pub_img.publish(msg_img);

		mhub.spinOne<std::shared_ptr<qrobot_msg_type1>>("main","topic1",g_fetchnum,g_isblock,error);
		ros::spinOnce();
		//loop_rate.sleep();
		usleep(g_sleep);
		++count;
         };





	prod1.join();
//	prod2.join();
//	prod3.join();


	mhub.release_T<std::shared_ptr<qrobot_msg_type1>>("topic1");
	mhub.release_T<std::shared_ptr<qrobot_msg_type2>>("topic2");
	mhub.release_T<std::shared_ptr<qrobot_msg_type3>>("topic3");
	mhub.release_T<std::shared_ptr<qrobot_msg_type4>>("topic4");

	return 0;
}

